//동기적 수행: 한번에 하나씩, 순서대로
console.log('작업 1');
print();
console.log('작업 3');

function print(){
  console.log('작업 2');
}
//직관적이여서 쉬운 방법이지만 오래 걸리는 작업을 하면 blocking 현상이 생긴다.(오래걸리는 작업에는 맞지 않음)

//비동기 프로그래밍:동기와는 다르게 작업이 진행되는 동안 나머지 작업도 진행 가능

setTimeout(() => {
  console.log('2');
},3000);

console.log('1');

//자바스크립트 엔진은 한번에 한가지 일만 할 수 있음- Web APIs(자바스크립트가 아닌 별도의 브라우저에서 실행)를 이용하여 비동기 프로그래밍(setTimeout,fetch,DOM)

//콜백함수: 다른 함수의 인자로 전달되는 함수

function main(callback){
  callback();
}

main(() => { });

//비동기 콜백: 비동기 작업이 완료되고 나서 후처리로 받아온 데이터를 처리하는 코드가 수행되도록 할 때 콜백함수를 사용하는 것

function gerData(callback){
  setTimeout(() => {
    console.log('서버에서 데이터를 받아왔어요.');
    callback({ name: 박중혁});
},2000);
}

getData((data) => {
  console.log(data.name);
});

//Promise:비동기 처리에 사용되는 자바스크립트 객체(비동기 작업이 맞이할 성공 혹은 실패를 나타냄)(Pending -> Fulfilled or Rejected)

const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const data = { name: '철수'};
    sonsole.log('네트워크 요청 성공');
  }, 1000);
});

console.log(promise);

//Async:function 앞에 써주면 비동기 함수가 됨, 항상 promise를 반환함
//await은 async함수 안에서만 동작함
//비동기 코드가 동기 코드처럼 읽히게 해줌

(async () => {
  const condition = true;
  const promise = new Promise((resolve, reject) => {
    if (condition) {
      resolve('resolved');
    } else {
      reject('rejected');
    }
  });

  try {
    const result = await promise;
    console.log(result);
  } catch (err) {
    console.error(err);
  }
})();

//Promise와 async&await의 차이점: Promise 를 활용할 시에는 .catch() 문을 통해 에러 핸들링이 가능하지만, async/await 은 에러 핸들링 할 수 있는 기능이 없어 try-catch() 문을 활용해야 한다
//Promise와 async&await의 차이점2: 코드가 길어지면 길어질수록, async/await 를 활용한 코드가 가독성이 좋다.