# 4주차

# 접근제어자

접근제어자란 클래스, 필드, 메서드 등 객체지향 프로그래밍 요소의 접근 범위를 제어하는 키워드로, 정보은닉과 모듈화의 핵심 도구이다.

## 접근제어자의 종류

접근제어자의 종류는 다음과 같다.

- public
- protected
- default
- private

각 접근제어자의 적용대상을 한번 알아보자.

접근제어자가 적용되는 대상은 크게 클래스와 멤버로 나뉜다.

앞서 말한 네 가지 접근제어자 중 public과 default는 클래스와 멤버, 둘 모두가 적용 대상인 반면, protected와 private은 오직 멤버만이 적용 대상이다.

이유는 간단하다.

클래스에 private이나 protected를 붙이면 외부에서 그 클래스를 사용할 수 없게 되는데, 그러면 애초에 존재할 이유가 없어지기 때문이다.

반면, 멤버는 클래스 안에서 세부적으로 보호하거나 공개할 필요가 있어서 네 가지 모두 적용되는 것이다.

이걸 하나의 표로 정리해보았다.

| **접근제어자** | **적용 대상** | **접근 범위 및 내부 처리 로직** |
| --- | --- | --- |
| public | 클래스, 멤버 | JVM이 모든 패키지, 모든 클래스에서 접근 허용. 외부 모듈, API, 테스트 코드 등에서 자유롭게 호출 가능. |
| protected | 멤버 | 동일 패키지 및 상속받은 하위 클래스에서만 접근 허용. JVM은 패키지 경계와 상속 계층을 체크하여 접근 권한 부여. |
| default | 클래스, 멤버 | (키워드 없음) 동일 패키지 내에서만 접근 허용. 패키지 외부에서는 컴파일 타임에 접근 불가로 처리. |
| private | 멤버 | 선언된 클래스 내부에서만 접근 허용. JVM은 외부 클래스, 하위 클래스, 패키지 모두에서 접근 시 컴파일 에러 발생. |

## 활용원칙

- 외부에 공개할 필요가 없는 멤버는 반드시 private으로 선언
- 상속 구조에서 하위 클래스에만 공개할 멤버는 protected
- 패키지 내부 협력용은 default
- 외부와의 명확한 계약(API, 라이브러리 등)은 public

## 활용시점

- 클래스/메서드/필드 설계 단계에서 멤버별로 최소 권한 원칙 적용
- 보안, 유지보수, 확장성, 테스트 용이성 등 다양한 품질 요구사항을 고려해 결정

접근제어자 설계는 객체지향 시스템의 안정성, 보안성, 확장성에 직접적인 영향을 미치므로, 코드 리뷰와 정적 분석 도구를 통해 지속적으로 점검하는 것이 중요하다.

혹여나, 접근제어자를 적절히 선택하지 않으면?

다음과 같은 문제들이 발생할 수 있다.

1. 정보 유출 및 보안 취약점
2. 내부 구현의 의도치 않은 노출
3. 불변성 및 무결성 훼손
4. 상속 구조의 오남용
5. 패키지 의존성 증가

# 키워드

## static

- 마치 학교 전체에 하나뿐인 ‘공용 우유 냉장고’처럼, static으로 선언된 변수나 메서드는 ‘클래스 전체에서 하나만’ 존재한다.
- 객체를 여러 개 만들어도 static 변수는 딱 하나만 공유되고, 객체 없이도 사용할 수 있다.

## this

- ‘나 자신’을 가리키는 말이다.
- 예를 들어, 반에 같은 이름이 두 명 있을 때, “나는 OOO야!”라고 자기 자신을 정확히 가리키는 것처럼, this는 현재 객체 자신을 의미한다.
- 주로 변수 이름이 겹칠 때 구분하거나, 자기 자신의 메서드나 필드를 가리킬 때 사용한다.

## final

- ‘한 번 정하면 바꿀 수 없는 것’이다.
- final로 선언된 변수는 값을 한 번만 할당할 수 있고, 이후로는 변경이 불가능하다.
- 클래스나 메서드에 붙이면, 상속이나 오버라이팅도 막을 수 있다.

# 오버로딩

오버로딩은 같은 이름의 메서드를 매개변수(입력값)의 개수나 타입만 다르게 여러 번 정의하는 개념이다.
이 개념이 생긴 이유는, 비슷한 동작을 하는 메서드를 이름만 다르게 계속 만들면 코드가 복잡해지고 헷갈리기 때문이다.

예를 들어, ‘더하기’라는 기능을 숫자 2개, 3개, 혹은 실수끼리도 하고 싶을 때, 각각 addInt, addDouble, addThreeInt처럼 이름을 다르게 만들면 외우기도 어렵고 코드가 지저분해진다.
오버로딩을 사용하면 add라는 이름 하나로 다양한 입력을 받아 처리할 수 있어, 코드가 훨씬 깔끔하고 사용하기 쉽다.

## 언제 사용하는가?

• 같은 동작이지만 입력값(매개변수)의 종류나 개수가 다를 때
• 사용자가 같은 이름으로 다양한 상황에 맞게 메서드를 호출할 수 있게 하고 싶을 때