**4주차 JS**
**JS로 HTML과 DOM 제작하기**


**1. DOM Tree와 DOM 선택자**
   <DOM 배경> 
   - 자바스크립트
   : 웹 문서를 제어(조작)하기 위해 개발된 언어로 요소 안에 컨텐츠를 변경, 다른 HTML요소를 추가/제거할 수 있음
   브라우저 안에는 웹 문서를 해석할 수 있는 렌더링 엔진이 있는데 브라우저로 HTML 파일을 열게 되면 렌더링 엔진이 HTML로 작성된 문서를 한 줄씩 해석하는 것을 알 수 있음 
   -> 해석이 끝나면 이런 문서를 객체화 해서 자바스크립트로 접근할 수 있도록 함. 
   -> 이 과정을 문서를 객체화 했다 해서 문서 객체 모델이라 부름
   즉 문서 객체 모델(Document Object Model)의 약어
   : 스크립트 언어로 HTMl요소를 제어할 수 있도록 웹문서를 객체화한 것을 의미

   DOM(웹문서의 객체화)<-> BOM(브라우저 자체를 제어할 수 있도록 모델링 한 것)
   
   - DOM의 구조
   트리구조
   : DOM의 구조로 하나의 부모태그와 n개의 자식태그를 가지고 있는 형태
   node
   : 트리구조의 각각의 요소
   - DOM트리의 최상위 노드 = document

   *<트리구조 예시>*
   Document
       - body
           - div
              - p.name("gain")


   HTMLCollection
   : 여러 개의 요소(노드)가 모여 있는 유사 배열 객체로 배열 처럼 생겼지만 배열의 모든 기능을 가지진 않음
   NodeList
   : 웹페이지에서 특정한 것을 찾아주는 도구

   *<HTMLCollection vs NodeList>*
   공통점 : 유사 배열 객체, DOM 요소들을 모아놓은 리스트
   차이점1_포함하는 대상
      HTMLCollection은 DOM요소들만 담겨있는 리스트지만 
      NodeList는 노드들을 담는 리스트라서 요소뿐만 아니라 텍스트, 주석 등도 포함할 수 있음
   차이점2_실시간 업데이트
      HTMLCollection은 실시간으로 동작 (LIve)
      NodeList은 실시간이 아님 (Static)
   차이점3_반복 처리
      HTMLCollection은 for, length 사용 가능
      NodeList은 for, length외에도 forEach()도 가능
   차이점4_반환하는 메서드 예시
      HTMLCollection는 getElementsByTagName가 있음
      NodeList은 querySelectorAll, childNodes가 있음


   DOM 선택자들
   : HTML 문서에서 원하는 요소를 찾아오는 명령어
      - getElementById("아이디명") : id로 하나 찾기
         = 하나만 찾음, 빠름
      - getElementsByClassName("클래스명") : class로 여러 개 찾기
         = 같은 클래스를 가진 여러 요소를 배열처럼 가져옴
      - getElementsByTagName("태그명") : 태그 이름으로 찾기
         = 특정 태그를 전부 찾아옴, HTMLCollection으로 반환
      - querySelector("CSS 선택자") : CSS처럼 하나 찾기
         = CSS선택자처럼 사용할 수 있음, 맨 처음 일치하는 요소 하나만 가져옴
      - querySelectorAll("CSS 선택자") : CSS처럼 여러 개 찾기
         = 일치하는 모든 요소를 NodeList형태로 반환

   *<getElementById vs querySelector>*
       대상 : id만 / CSS 선택자 전부
       반환 : 1개  / 첫 번째 일치 요소
       속도 : 더 빠름 / 조금 느릴 수 있음
       예시 : #title / #title, .class , div 

   *<셀렉터 예시1>_HTML*
      <p id="hello">안녕하세요!</p>shem 

      <script>
         const hi = document.getElementById('hello');
         hi.style.color = 'red'; 
      </script>

  *<셀렉터 예시2>_JS*
      const gain = document.getElementById('gain');
      gain.style.color = 'yellow'; // 이름을 노랗게 만들 수 있음

   *<셀렉터 예시3>_JS*
      let divs = document.getElementsByTagName("div"); 
      // 모든 div 태그를 찾음 
      // 반환된 결과는 divs에 저장 
      // 만약 여러 개를 찾으면 HTMLCollection으로 반환


**2. 이벤트리스너란?**
   이벤트
   : 사용자나 브라우저가 발생시키는 모든 행동이나 사건 
   ex. 클릭, 더블클릭, 키보드 입력, 마우스 이동, 폼 제출, 페이지 로드 등
   이벤트 리스너
   : 이벤트가 발생했을 때 콜백을 등록하는 메커니즘
   addEventListener(type, listener, options)
   : 이벤트 리스너 등록함수
      - type : 이벤트 종류 (click, keydown 등)
      - listener : 이벤트 발생 시 실행할 함수
      - options : 캡쳐링, once, passive 등 이벤트 처리 옵션

   *<이벤트 리스너 에시>_JS*
   const button = document.getElementById('button');

   button.addEventListener('click', (event) => {
      console.log('버튼 클릭');
      console.log(event); // -> 이벤트 객체
   });

   이벤트 리스너 옵션
   - capture : 캡처링 단계에서 실행 여부
   - once : 한 번만 실행 후 자동 제거
   - passive : true로 설정하면 이벤트 핸들러가 preventDefault()를 호출하지 않겠다는 의미
   - signal : AbortSignal 객체를 이용해 이벤트리스너를 나중에 제거 가능
   
   이벤트 제거
   -  등록할 때와 동일한 함수 참조로 removeEventListener 활용해 제거 가능 (익명함수는 제거 불가능)
   AbortSignal이란?
   : 이벤트리스너를 포함한 여러 비동기 작업을 나중에 취소할 수 있게 해주는 신호
      - AbortController객체와 주로 함께 사용
      - AbortController = 작업 취소 / AbortSignal = 취소 신호를 나타냄

   *<이벤트 리스너 제거 예시>_JS*
   const controller = new AbortController();
   const signal = controller.signal;
   const button = document.getElementById('button');
   button.addEventListener('click', (event) => {
      console.log('버튼 클릭');
   }, { signal });

   controller.abort(); //signal->abort 상태가 되면서 이벤트리스너 제거
   

**3. 이벤트 버블링과 캡쳐링**
   이벤트 버블링과 캡쳐링은 이벤트 전파 방식을 의미한다. 

   이벤트 전파 방식
   - HTML 요소는 트리 구조(부모-자식 관계)로 이루어져 있음
   - 어떤 요소에 이벤트가 발생하면 브라우저는 다음 순서로 이벤트를 캡처링->타깃->버블링 단계로 전달함.
      1. 캡처링 단계
      : 문서 최상단에서 이벤트 발생 요소까지 내려옴
      2. 타깃 단계
      : 실제 이벤트가 발생한 요소
      3. 버블링 단계 
      : 타깃에서 부모 요소를 향해 이벤트가 올라감

   *<이벤트 전파 예시1>_HTML*
   <div id="outer">
      <div id="middle">
      <button id="inner">클릭</button>
      </div>
   </div>
   // DOM트리의 구조가 outer-middle-inner로 생겼음
   // 캡처링 단계 : outer-middle-inner 순으로 이벤트를 찾아감
   // 타깃 단계 : 이벤트가 실제로 발생한 타깃 요소(=inner)에 도달
   // 버블링 단계 : inner-middle-outer 순서로 거슬러 올라감


   이벤트 버블링 (Bubbling)
   : 이벤트가 안쪽 요소 -> 바깥 요소로 전달되며 올라감 (자식 -> 부모)
   - 하나의 부모 요소에 이벤트를 걸고 자식들 클릭을 한꺼번에 처리할 때 사용 (실무 사용도 높음)
   이벤트 캡처링 (Capturing)
   : 이벤트가 바깥 요소 -> 안쪽 요소로 전달되며 내려감 (부모 -> 자식)
   - 보안이나 순서 제어 등 특정 상황에서만 사용 (실무 사용도 낮음)
   타깃
   : 이벤트가 실제 발생한 요소

   *<이벤트 전파 예시2>_HTML*
   <!DOCTYPE html>
   <html>
   <body>
      <div id="parent">
      <button id="child">클릭!</button>  
      </div>
      <script>
         const parent = document.getElementById("parent");
         const child = document.getElementById("child");

         parent.addEventListener("click", () => {
         console.log("Parent 클릭");
         });

         child.addEventListener("click", () => {
         console.log("Child 클릭");
         });
      </script>
   </body>
   </html>
   //child가 클릭되면서 이벤트 발생
   // child에 등록된 리스너 실행, parent에 등록된 리스너 실행 -> 버블링


   이벤트 전파 멈추기
   - event.stopPropagation()
     : 이벤트가 부모나 자식에게 전달되지X
   - event.stopImmediatePropagation()
     : 같은 요소에 여러 리스너가 있을 경우 나머지가 실행이 안됨

   //이벤트는 캡처링으로 내려오고, 버블링으로 올라간다. 중간에 막을 수도 있고, 타깃은 무조건 찍고 간다

