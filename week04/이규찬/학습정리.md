# Java: 접근제어자, static, this, final, 오버로딩 — 전문적으로 정리

## 학습 주제 및 목표

- **주제:** Java의 접근제어자, static, this, final 키워드, 오버로딩의 동작 원리와 활용
- **목표:**
  - 접근제어자(Access Modifier)의 종류와 역할, 실무에서의 사용 이유 이해
  - static, this, final 키워드의 의미와 적절한 활용법 습득
  - 오버로딩(Overloading)의 원리, 필요성, 자바 언어적 배경 고찰
  - 실제 개발 상황에서 마주치는 질문과 해결 과정 제시

---

## 1. 접근제어자 (Access Modifiers)

### 1.1. 접근제어자의 필요성

- **캡슐화(Encapsulation)**의 핵심 도구: 내부 구현(데이터, 메소드)을 감추고 외부에서는 필요한 만큼만 노출
- **보안(Security) 및 안정성**: 객체의 불필요한 접근 차단, 잘못된 사용이나 데이터 변경 방지
- **유지보수성**: 인터페이스와 구현 분리로 코드 변경 시 영향 최소화

### 1.2. 종류와 특징

| 접근제어자 | 적용 대상            | 접근 허용 범위                                       |
| ---------- | -------------------- | ---------------------------------------------------- |
| public     | 클래스, 필드, 메소드 | 모든 클래스에서 접근 가능                            |
| protected  | 필드, 메소드         | 동일 패키지 + 다른 패키지의 자식 클래스              |
| (default)  | 필드, 메소드         | 동일 패키지 내에서만 접근(아무 접근제어자 미사용 시) |
| private    | 필드, 메소드         | 선언된 클래스 내부에서만 접근 가능                   |

> **TIP:** 설계 시, 기본적으로 가장 제한적인 `private`를 사용하고, 점진적으로 공개 범위를 확장하는 것이 유지보수와 보안에 유리합니다.

---

## 2. static, this, final 키워드

### 2.1. static

- **정적 멤버**: 클래스 단위에 소속, 모든 인스턴스(객체)에서 공유
- **할당 시기**: 프로그램 실행 시 클래스가 메모리에 로드될 때
- **대표적 용도**:
  - 유틸리티 함수(`Math.sqrt()`)
  - 공통 설정값, 카운트 등 모든 객체에서 공유할 값

```java
public class Counter {
  private static int count = 0;
  public Counter() {
    count++;
  }
  public static int getCount() {
    return count;
  }
}
```

---

### 2.2. this

- **현재 인스턴스 자신을 참조**
- **주요 용도**:
  - 매개변수와 멤버 변수명 중복 시 구분
  - 자신의 생성자 또는 메소드 호출 (`this()`)
  - 메소드 체이닝에서 자기 자신 반환

```java
public class Student {
  private String name;
  public Student(String name) {
    this.name = name;
  }
  public Student setName(String name) {
    this.name = name;
    return this;
  }
}
```

---

### 2.3. final

- **변경 불가(Immutable) 속성 부여**
  - 변수: 단 한 번만 값 할당 가능(상수)
  - 메소드: 하위 클래스에서 재정의(Override) 불가
  - 클래스: 상속 불가

```java
public final class Constants {
  public static final double PI = 3.14159; // 값 변경 불가
}
```

---

## 3. 오버로딩 (Overloading)

### 3.1. 원리 및 필요성

- 하나의 클래스 내에서 **동일한 이름의 메소드**를 **매개변수 타입/개수/순서**에 따라 여러 개 정의
- **이점**:
  - 코드 가독성 증대
  - 함수명 일관성으로 인한 유지보수성 향상
  - 유연한 매개변수 처리 가능

```java
public class Calculator {
  public int add(int a, int b) { return a + b; }
  public double add(double a, double b) { return a + b; }
  public int add(int a, int b, int c) { return a + b + c; }
}
```

---

### Q1. static 메소드에서 인스턴스 변수를 사용할 수 없는 이유는?

- static 메소드는 클래스 레벨로 동작하며, 객체 생성 없이 호출 가능.
- 인스턴스 변수는 객체 생성 후 메모리에 올라가므로, static 메소드에선 바로 참조 불가.

### Q2. 오버로딩 vs 오버라이딩 차이

| 구분        | 오버로딩(Overloading)        | 오버라이딩(Overriding)                 |
| ----------- | ---------------------------- | -------------------------------------- |
| 적용 위치   | 같은 클래스                  | 상속 관계(자식 클래스)                 |
| 기준        | 매개변수 타입/개수/순서 변경 | 메소드 시그니처(이름, 파라미터)가 동일 |
| 바인딩 시점 | 컴파일 타임                  | 런타임(동적 바인딩)                    |

## 정리

- **접근제어자**: 정보 은닉, 보안 강화
- **static**: 클래스 공유 자원, 객체 없이 사용 가능
- **this**: 인스턴스 참조, 변수/메소드 구분
- **final**: 불변성 부여, 상속/오버라이딩 방지
- **오버로딩**: 같은 이름, 다른 매개변수 → 유지보수 편리

---
